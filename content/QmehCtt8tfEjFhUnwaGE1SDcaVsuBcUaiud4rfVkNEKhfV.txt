{"tags":["testing","tutorial","truffle","solidity"],"id":"f95f956261494090be1aaa8227464773_8","article_id":"f95f956261494090be1aaa8227464773","article_version":8,"title":"Truffle: Testing your smart contract","content":"{\"markdown\":\"\\nEarlier in the series, we took a look at how to setup Truffle and use it to compile, deploy and interact with our Bounties.sol smart contract.\\n\\nThis article will walk through the steps required to write tests for our smart contract within the Truffle framework. Tests in Truffle projects can be written in [Javascript] (http://truffleframework.com/docs/getting_started/javascript-tests) or [Solidity] (http://truffleframework.com/docs/getting_started/solidity-tests), however, this article will focus on the Javascript tests.\\n\\nTruffle uses the [Mocha] (https://mochajs.org/) testing framework to provide an easy way to write tests in Javascript and uses [Chai] (http://www.chaijs.com/api/assert/) for assertions. You can read more about [testing in Truffle here] (https://truffleframework.com/docs/truffle/testing/testing-your-contracts).\\n\\n[Source code for this tutorial can be found here.] (https://github.com/kauri-io/kauri-fullstack-dapp-tutorial-series/tree/master/truffle-writing-tests)\\n\\n## Prerequisites\\n\\n**NODEJS 7.6+**\\n\\nSince web3.js and truffle executios are asynchronous, we'll be using [async/await] (https://hackernoon.com/6-reasons-why-javascripts-async-await-blows-promises-away-tutorial-c7ec10518dd9) to simplify our test code. You’ll have to upgrade to Node 7.6 or higher. \\n\\n**TRUFFLE**\\n```\\n$ npm install -g truffle\\n```\\nRead more on [installing truffle here] (https://truffleframework.com/docs/truffle/getting-started/installation).\\n\\n**Truffle Project**\\n\\nIn order to test our Bounties.sol smart contract we'll need to have a truffle project set up to compile and deploy our smart contract. Let's start with the truffle project we created earlier in the series:\\n```\\n$ git clone https://github.com/kauri-io/kauri-fullstack-dapp-tutorial-series.git\\n$ cd kauri-fullstack-dapp-tutorial-series\\n$ cp -R truffle-compilation-and-deploy dapp-series-bounties\\n$ cd dapp-series-bounties\\n```\\nWe'll also need to install the **truffle-hdwallet-provider** dependency, to ensure the project compiles:\\n```\\n$ npm install truffle-hdwallet-provider@web3-one --save\\n```\\n\\n**Development Blockchain: Ganache-CLI**\\n\\nIn order to deploy our smart contract, we’re going to need an Ethereum environment to deploy to. For this, we will use Ganache-CLI to run a local development environment\\n\\nNOTE: If you have a windows machine you will need to install the windows developer tools first\\n```\\nnpm install -g windows-build-tools\\n```\\n```\\n$ npm install -g ganache-cli\\n```\\n\\n**Note For Windows Users:**\\n\\nYou should install promise and bindings to ensure there are no errors later on. \\n\\n`npm install mz`   \\n\\n`npm install bindings`\\n\\n## Setting up a test file\\n\\nNow that we have our project setup we'll create our first test:\\n\\n\\n* First, we need to create a file named bounties.js  inside the **/test** folder\\n* Within our bounties.js file we need to import the Bounties.sol artifact so we can use it within our tests\\n```\\nconst Bounties = artifacts.require(\\\"./Bounties.sol\\\");\\n```\\n* We'll also now define a contract container which where our tests for this contract will live, usually set this to the name of the contract, however, this is not required, you can use any text you like.\\n```\\ncontract('Bounties', function(accounts) {\\n\\n  let bountiesInstance;\\n\\n  beforeEach(async () => {\\n      bountiesInstance = await Bounties.new()\\n   })\\n   \\n});\\n```\\n* Within the contract container, we also define a variable to hold the contract instance being tested **bountiesInstance**, and a **beforeEach** block\\n* The **beforeEach** block will execute before each test and will deploy a new instance of the Bounties.sol smart contract. This ensures each test is executed against a clean contract state\\n\\nYour bounties.js file should look as follows:\\n\\n![](https://api.beta.kauri.io:443/ipfs/QmcFV9NNxnKaxa2kGxj3kRpC59Yhf9TCmqVcHvidRudjxb)\\n\\nAt this point, we have the basic skeleton of our test file and we can test everything is set up correctly by executing the following:\\n\\nFirst in a separate window start ganache-cli:\\n```\\n$ ganache-cli\\n```\\nNext, run the **truffle test** command:\\n```\\n$ truffle test\\n```\\n\\n\\nRunning truffle test executes all tests in your truffle projects **/test** folder. This does the following:\\n\\n1. Compiles your contracts\\n2. Runs migrations to deploy the contracts to the network\\n3. Runs tests against the contracts deployed on the network\\n\\n## Writing a Test\\n\\nLet's take a look at the issueBounty function:\\n```\\nfunction issueBounty(\\n  string _data,\\n  uint64 _deadline\\n)\\n  external\\n  payable\\n  hasValue()\\n  validateDeadline(_deadline)\\n  returns (uint)\\n{\\n  bounties.push(Bounty(msg.sender, _deadline, _data, BountyStatus.CREATED, msg.value));\\n  emit BountyIssued(bounties.length - 1,msg.sender, msg.value, _data);\\n  return (bounties.length - 1);\\n}\\n```\\nThere are a few things we would want to test within this function:\\n\\n* **happy path**: Issuing a bounty should emit a BountyIssued event\\n* **happy path:** Calling issueBounty should return an integer\\n* **payable** keyword: Issuing a bounty without sending a value should fail\\n* **hasValue** modifier: Issuing a bounty with a value of 0 should fail\\n* **validateDeadline** modifier: Issuing a bounty with a deadline not greater than now should fail\\n\\n**Helper Functions**\\n\\nWhere we are expecting the input validation to fail, we expect to get a *revert* error from the EVM. You can [read more about error handling in Solidity here] (https://solidity.readthedocs.io/en/v0.4.24/control-structures.html?highlight=revert#error-handling-assert-require-revert-and-exceptions).\\n\\nAlso to create our bounty, we'll need to pass in a deadline which is greater than the current timestamp on the EVM.\\n\\nTo do this we'll need to write some helper functions to assist us in writing our tests:\\n\\n* First, create a folder in the **/test** directory named **utils** and create a file **time.js**\\n* Copy the following extract into **time.js**\\n```\\nfunction getCurrentTime() {\\n\\treturn new Promise(function(resolve) {\\n  \\tweb3.eth.getBlock(\\\"latest\\\").then(function(block) {\\n\\t\\t\\tresolve(block.timestamp)\\n\\t\\t});\\n\\t})\\n}\\n\\nObject.assign(exports, {\\n  getCurrentTime\\n});\\n```\\n\\nThe above extract uses the web3 library to get the **latest** block from the EVM and from that return its timestamp. \\n\\n* Create a file named **assertRevert.js** inside the **/test/utils** directory\\n* Copy the following extract into **assertRevert.js**\\n```\\nvar assertRevert = async (promise, message) => {\\n  let noFailureMessage;\\n  try {\\n    await promise;\\n    \\n    if (!message) { \\n      noFailureMessage = 'Expected revert not received' \\n    } else {\\n      noFailureMessage = message;\\n    }\\n\\n    assert.fail();\\n  } catch (error) {\\n    if (noFailureMessage) {\\n      assert.fail(0, 1, message);\\n    }\\n    const revertFound = error.message.search('revert') >= 0;\\n    assert(revertFound, `Expected \\\"revert\\\", got ${error} instead`);\\n  }\\n};\\n\\nObject.assign(exports, {\\n  assertRevert\\n});\\n```\\n\\n![](https://api.beta.kauri.io:443/ipfs/QmWaFwv1udeBqcEwHixre55igXssD9RaLNPeuQyvirwsmX)\\n\\nThe above extract takes a promise as its first argument, which would be a web3 transaction, and an assertion fail message as the next. It wraps the promise in a try and catches the error,  if the promise fails it checks if the error message contains the string **\\\"revert”**.\\n\\nWe can now import our helper function into our bounties.js test file, by adding the following lines:\\n```\\nconst getCurrentTime = require('./utils/time').getCurrentTime;\\nconst assertRevert = require('./utils/assertRevert').assertRevert;\\nconst dayInSeconds = 86400;\\n```\\nWe also added a **dayInSeconds** constant, to help us add days.\\n\\n### Happy Path\\n\\n**Note: all the following tests should be placed in the bounties.js file**\\n\\nThe test for our first happy path looks like this:\\n```\\n  it(\\\"Should allow a user to issue a new bounty\\\", async () => {\\n   let time = await getCurrentTime()\\n   let tx = await bountiesInstance.issueBounty(\\\"data\\\",\\n                               time + (dayInSeconds * 2),\\n                               {from: accounts[0], value: 500000000000});\\n\\n   assert.strictEqual(tx.receipt.logs.length, 1, \\\"issueBounty() call did not log 1 event\\\");\\n   assert.strictEqual(tx.logs.length, 1, \\\"issueBounty() call did not log 1 event\\\");\\n   const logBountyIssued = tx.logs[0];\\n   assert.strictEqual(logBountyIssued.event, \\\"BountyIssued\\\", \\\"issueBounty() call did not log event BountyIssued\\\");\\n   assert.strictEqual(logBountyIssued.args.bounty_id.toNumber(),0, \\\"BountyIssued event logged did not have expected bounty_Id\\\");\\n   assert.strictEqual(logBountyIssued.args.issuer, accounts[0], \\\"BountyIssued event logged did not have expected issuer\\\");\\n   assert.strictEqual(logBountyIssued.args.amount.toNumber(),500000000000, \\\"BountyIssued event logged did not have expected amount\\\");\\n\\n });\\n```\\n\\nThere is a lot going on here but its quite simple:\\n\\n* Each test starts with the function `it()` which takes a description of the test as its first arguments and a callback function as the next. We use `async()` as the callback so we can use `await`\\n\\n* We then invoke an `issueBounty` transaction on our `bountiesInstance` object, using our `getCurrentTIme()` helper to ensure our deadline is valid\\n\\n* The transaction is sent from `account[0]` with a value of `500000000000000000`\\n\\n* We then `assert` that our transaction receipt contains a log of exactly 1 event.\\n\\n* We then assert that the details of the event are as expected\\n\\n\\nOur second happy path which tests making a call to `issueBounty` rather than sending a transaction looks like this:\\n\\n```\\n it(\\\"Should return an integer when calling issueBounty\\\", async () => {\\n   let time = await getCurrentTime()\\n   let result = await bountiesInstance.issueBounty.call(\\\"data\\\",\\n                               time + (dayInSeconds * 2),\\n                               {from: accounts[0], value: 500000000000});\\n\\n   assert.strictEqual(result.toNumber(), 0, \\\"issueBounty() call did not return correct id\\\");\\n });\\n```\\n\\nAbove we add `.call` to issueBounty to make a call to the function rather than issuing a transaction. This returns the return value of the function rather than a transaction receipt.\\n\\n**NOTE: Because our result is a BigNumber, we need to call .toNumber() in our assert function.**\\n\\n### Error Path\\n\\nOur error path tests will involve us sending a transaction with invalid inputs as an argument to our `assertRevert` helper function\\n\\nTo test our payable keyword, we invoke a transaction without a value being set:\\n\\n```\\nit(\\\"Should not allow a user to issue a bounty without sending ETH\\\", async () => {\\n     let time = await getCurrentTime()\\n     assertRevert(bountiesInstance.issueBounty(\\\"data\\\",\\n                                 time + (dayInSeconds * 2),\\n                                 {from: accounts[0]}), \\\"Bounty issued without sending ETH\\\");\\n\\n   });\\n```\\n\\nTo test our hasValue() modifier, we invoke our transaction with a value of 0:\\n\\n```\\nit(\\\"Should not allow a user to issue a bounty when sending value of 0\\\", async () => {\\n      let time = await getCurrentTime()\\n      assertRevert(bountiesInstance.issueBounty(\\\"data\\\",\\n                                  time + (dayInSeconds * 2),\\n                                  {from: accounts[0], value: 0}), \\\"Bounty issued when sending value of 0\\\");\\n\\n    });\\n```\\n\\nTo test our validateDeadline modifier, we need to send two transactions, one with a deadline set in the past, and another with a deadline set as now:\\n\\n```\\nit(\\\"Should not allow a user to issue a bounty with a deadline in the past\\\", async () => {\\n        let time = await getCurrentTime()\\n        assertRevert(bountiesInstance.issueBounty(\\\"data\\\",\\n                                    time - 1,\\n                                    {from: accounts[0], value: 0}), \\\"Bounty issued with deadline in the past\\\");\\n\\n      });\\n\\n  it(\\\"Should not allow a user to issue a bounty with a deadline of now\\\", async () => {\\n          let time = await getCurrentTime()\\n          assertRevert(bountiesInstance.issueBounty(\\\"data\\\",\\n                                      time,\\n                                      {from: accounts[0], value: 0}), \\\"Bounty issued with deadline of now\\\");\\n        });\\n```\\nSo now if we run the truffle test command we should see the following:\\n```\\n$ truffle test\\n\\nCompiling ./contracts/Bounties.sol...\\nCompiling ./contracts/Migrations.sol...\\n\\n\\n  Contract: Bounties\\n    ✓ Should allow a user to issue a new bounty (207ms)\\n    ✓ Should return an integer when calling issueBounty (142ms)\\n    ✓ Should not allow a user to issue a bounty without sending ETH (116ms)\\n    ✓ Should not allow a user to issue a bounty when sending value of 0 (100ms)\\n    ✓ Should not allow a user to issue a bounty with a deadline in the past (109ms)\\n    ✓ Should not allow a user to issue a bounty with a deadline of now (110ms)\\n\\n\\n  6 passing (1s)\\n```\\n \\n### Time travel\\n\\nOne of the main tests is to check that a fulfilment should not be accepted if the deadline has passed. In order to test this, we will need to add a helper function which advances the timestamp of the EVM:\\n\\nIn the **/test/utils/time.js** file add the following:\\n\\n```\\nfunction increaseTimeInSeconds(increaseInSeconds) {\\n    return new Promise(function(resolve) {\\n        web3.currentProvider.send({\\n            jsonrpc: \\\"2.0\\\",\\n            method: \\\"evm_increaseTime\\\",\\n            params: [increaseInSeconds],\\n            id: new Date().getTime()\\n        }, resolve);\\n    });\\n};\\n```\\nThis function calls the `evm_increaseTime` RPC function of the ganache EVM to increase the EVM block timestamp.\\n\\nAdd the new `increaseTimeInSeconds` function to the exports section of the file:\\n```\\nObject.assign(exports, {\\n  increaseTimeInSeconds,\\n  getCurrentTime\\n});\\n```\\nIn the **bounties.js** test file add the following line to import our new helper function:\\n```\\nconst increaseTimeInSeconds = require('./utils/time').increaseTimeInSeconds;\\n```\\nWe can then use this in our test as follows:\\n\\n```\\n  it(\\\"Should not allow a user to fulfil an existing bounty where the deadline has passed\\\", async () => {\\n   let time = await getCurrentTime()\\n   await bountiesInstance.issueBounty(\\\"data\\\",\\n                     time+ (dayInSeconds * 2),\\n                     {from: accounts[0], value: 500000000000});\\n\\n   await increaseTimeInSeconds((dayInSeconds * 2)+1)\\n\\n   assertRevert(bountiesInstance.fulfillBounty(0,\\\"data\\\",{from: accounts[1]}), \\\"Fulfillment accepted when deadline has passed\\\");\\n\\n });\\n```\\n\\n## Try it yourself\\n\\nNow that you have seen how to test the issueBounty function, try adding tests for the following functions:\\n\\n* fulfilBounty\\n* acceptFulfilment\\n* cancelBounty\\n\\nYou can find the [complete bounties.js test file here for reference]  (https://github.com/kauri-io/kauri-fullstack-dapp-tutorial-series/blob/master/truffle-writing-tests/test/bounties.complete.js)\\n\\n## Next Steps\\n- Read the next guide: [Truffle: Adding a Frontend with React Box](https://kauri.io/article/86903f66d39d4379a2e70bd583700ecf/truffle:-adding-a-frontend-with-react-box)\\n- Learn more about the Truffle suite of tools from the [website](https://truffleframework.com/)\\n\\n>If you enjoyed this guide, or have any suggestions or questions, let me know in the comments. \\n\\n>If you have found any errors, feel free to update this guide by selecting the **'Update Article'** option in the right hand menu, and/or [update the code](https://github.com/kauri-io/kauri-fullstack-dapp-tutorial-series/tree/master/truffle-react-box-frontend)\\n\\n\\n\\n\\n\\n\\n\"}","author":"7b88584d0e6a608fa3a8716b0ca1620d61834a0c","timestamp":1556790659098,"attributes":{}}